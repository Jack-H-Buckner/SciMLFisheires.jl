var documenterSearchIndex = {"docs":
[{"location":"ModelBuilders/#Building-a-model","page":"Building a model","title":"Building a model","text":"","category":"section"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"SciMLFisheries has one primary function for building a fisheries assessment model, SurplusProduction. This function only requires a data set to build a model but offers several keyword arguments to allow users to modify the model structure, incorperate prior information, and optimize model performance. The function of these arguments depends on the model type and is discussed in detail below.","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"SciMLFisheries.SurplusProduction(data;kwargs ...)","category":"page"},{"location":"ModelBuilders/#SciMLFisheries.SurplusProduction-Tuple{Any}","page":"Building a model","title":"SciMLFisheries.SurplusProduction","text":"SurplusProduction(data;kwargs ...)\n\nInitailizes a surplus production model to fit to the data set with a colum for time, harvest and the abundnace index. \n\ntable 1: example data set \n\nt y H\n0 1.0 0.1\n1 0.95 0.15\n2 0.925 0.125\n... ... ...\n\nA number of key work arguments are used to modify the models behavior. Each of the key words specifies a specific model sturcture or model behavior, see the section on model types for details. \n\nSurplusProduction(data;\n        production_model = \"DelayEmbedding\", # options = [\"FeedForward\",\"LSTM\",\"DelayEmbeddingARD\",\"DelayEmbeddingDropOut\",\"LSTMDropOut\"]\n        harvest_model = \"DiscreteAprox\", # options = [\"FeedForward\"]\n        index_model = \"Linear\", # index_model = [\"Nonlinear\"]\n        regularizaiton_type = \"L2\", # options = [\"L1\"]\n        regularizaiton_weight = 10^-4, # options Real\n        loss = \"FixedVariance\", # options = [\"EstimateVariance\"]\n        process_weights = [0.5,1.0], # options:  Vector{Real}\n        observation_weights = [0.25,0.1], # options: Vector{Real}\n        produciton_hyper_parameters = NamedTuple(), # options: Naned tuple with keys (lags=Int,hidden=Int,cell_dim=Int,seed=Int,drop_prob=Real in [0,1],extrap_value=Real,extrap_length=Real)\n        prior_q = 0.0, # options: Real\n        prior_b = 0.0 # options: Real\n        prior_weight = 0.0 # options = Real\n        variance_priors = NamedTuple() # named tuple with keys (var_y=Real,sigma_y=Real,rH=Real,sigma_rH=Real,rB=Real,sigma_rB=Real,rF=Real,sigma_rF=Real)\n    )\n\n\n\n\n\n","category":"method"},{"location":"ModelBuilders/#Production-models","page":"Building a model","title":"Production models","text":"","category":"section"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"The core of the surplus production model is a function that estimates the growth rate of the population in each time step r_t. SciMLFisheries had six choices in production models that fall into one of three primary categories: time delay embedding models, recurrent neural networks, and feed-forward neural networks.  ","category":"page"},{"location":"ModelBuilders/#Time-Delay-Embedding","page":"Building a model","title":"Time Delay Embedding","text":"","category":"section"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"Time delay embedding models estimate the growth rate at time t  time step as a function of the current biomass B_t and prior observations of the biomass and fishing mortality up to time t-tau where tau is the \"embedding\" dimension, a use specified parameter that determines how much of the population’s history is included in the model.","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"The simplest model uses a neural network parameterized with weight w and biases b to approximate a function that maps from the prior observations to the population growth rate.","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"r_t = NN(B_tB_t-i_i=1^tau H_t-i_i=1^tauwb)","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"We can build a delay embedding model using the SurplusProduction function by specifying \"DelayEmbedding\" as the     production_model argument. The Delay embedding model had five hyperparameters that can be tuned to optimize the model's performance. In this example, all five parameters are listed in the NamedTuple produciton_hyper_parameters and set to their default values. The embedding dimension tau is set equal to lags and must take an integer value. The next argument, hidden, influences how complex (degree of nonlinearity) the production function can be by controlling the number of hidden units in the neural network. The argument seed initializes the random number generator used to sample the initial neural network parameters, and the parameters extrap_value and extrap_length determine the behavior of the model predictions when extrapolating outside of the observed data set. The predicted growth rate will revert to extrap_value in the limit as the abundance of the stock becomes small, and it will revert to -1*extra_value in the limit as the stock becomes large. extrap_length determines how quickly the model reverts to this default behavior outside the range of historical observations. When forecasting, the production model is determined by the fitted neural network F(B) and the extrapolation parameters","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"   r_t =    left\nbeginarrayll\n     omega(B)F(B) + (1-omega(B)) extrap_value  B  min(B_t) \n     F(B)   min(B_t) leq B_t leq max(B_t) \n     omega(B)F(B) - (1-omega(B)) extrap_value  B   max(B_t) \nendarray\nright  \nw(B) = e^-frac12left( fracmin(min(B_t)-B)B - max(B_t))^2extrap_length right)^2","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"where min(B_t) is the smallest observation in the data set and max(B_t) is the largest. We can also specify the functional form and weight for regularizing the neural network parameters when building the models, using the regualrizaiton_type and regularization_weight arguments. When using the default L2 regularization, the sum of squares penalizes the neural network weights, and L1 uses the sum of absolute values times the regularization_weight.","category":"page"},{"location":"ModelBuilders/","page":"Building a model","title":"Building a model","text":"using UniversalDiffEq\nmodel = SurplusProduction(data,\n                        production_model = \"DelayEmbedding\", # options Int\n                        produciton_hyper_parameters = (lags=5,hidden=10,seed=123,extrap_value=0.0,extrap_length=0.5),\n                        regularizaiton_type = \"L2\", # options [\"L2\", \"L1\"]\n                        regularizaiton_weight = 10^-4 # options Real {x | x >= 0}\n                        )","category":"page"},{"location":"ModelBuilders/#Recurrent-nerual-networks","page":"Building a model","title":"Recurrent nerual networks","text":"","category":"section"},{"location":"ModelBuilders/#Feed-Forward-Networks","page":"Building a model","title":"Feed Forward Networks","text":"","category":"section"},{"location":"ModelBuilders/#Observation-models","page":"Building a model","title":"Observation models","text":"","category":"section"},{"location":"ModelBuilders/#Discrete-approximation","page":"Building a model","title":"Discrete approximation","text":"","category":"section"},{"location":"ModelBuilders/#Linear-approximation","page":"Building a model","title":"Linear approximation","text":"","category":"section"},{"location":"ModelBuilders/#Uncertianty-quantification","page":"Building a model","title":"Uncertianty quantification","text":"","category":"section"},{"location":"ModelBuilders/#Process-errors","page":"Building a model","title":"Process errors","text":"","category":"section"},{"location":"ModelBuilders/#Observation-errors","page":"Building a model","title":"Observation errors","text":"","category":"section"},{"location":"ModelBuilders/#Priors","page":"Building a model","title":"Priors","text":"","category":"section"},{"location":"Modeltesting/#Testing-model-performance","page":"Testing model performance","title":"Testing model performance","text":"","category":"section"},{"location":"ModelEvaluation/#Using-the-fitted-model","page":"Using the fitted model","title":"Using the fitted model","text":"","category":"section"},{"location":"#SciMlFisheries","page":"SciMlFisheries","title":"SciMlFisheries","text":"","category":"section"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"Many interacting factors, including harvest, physical climate and oceanographic conditions, and species interactions, can influence the abundance of fish populations. Two important goals in fisheries science are understanding how these complex interactions influence fish population dynamics and designing management strategies that account for them. We aim to address this challenge by combining standard fisheries models with novel machine-learning techniques.","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"Machine learning methods have been very successful at reconstructing the dynamics of complex systems, including popautlion dynamics. Machine learning techniques have been so effective because they are flexible and, therefore, can represent complex nonlinear interactions when they are present. Machine learning techniques can also incorporate information from past observations to inform predictions, which is very helpful when that data set does not include all relevant state variables. This may often be the case in fisheries science because fish populations are embedded in complex ecosystems and interact with species that may or may not be observed directly.","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"Here, we aim to develop new models that combine standard fisheries modeling techniques with machine learning tools to leverage the potential advantages of these methods while accounting for the multiple sources of uncertainty common in fisheries data. The models are built using a surplus production or \"Biomass dynamics” framework, where machine learning is used to estimate the production function.  These machine learning-based production models can incorporate prior observations that implicitly account for species interactions and other ecosystem feedbacks that operate on extended time scales. Models like these that combine machine learning with parametric models are often called Scientific Machine Learning, which lends its name to our package.","category":"page"},{"location":"#Model-structure","page":"SciMlFisheries","title":"Model structure","text":"","category":"section"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"SciMLFisheries uses a state space modeling framework. State space models are a class of time series models that describe a sequence of observations by combining two models: 1) the process model that describes how the state of a system changes over time, and 2) the data model that describes how the state of a system determines the observations. Combining the two models allows the state space model to account for noisy, imperfectly measured data and random variability in the system state.","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"The surplus production models describe two data sources, harvest H_t and a relative abundance index y_t. Using these two data sources, the models estimate two state variables, the population biomass B_t and fishing mortality rate F_t. There are two built-in observation models for the abundance index. The first assumes a proportional relationship between biomass and the abundance index with a scaling factor q and with normally distributed observaiton errors with variance sigma^2","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"log(B_t) = log(y_t) - q + epsilon_yt\nepsilon_yt sim N(0sigma_y)","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"The second model allows for some nonlinearity in the relationship by adding a third parameter b","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"log(B_t) = blog(y_t) - q + epsilon_yt\nepsilon_yt sim N(0sigma_y)","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"When b is less than one, the index is more sensitive to changes in biomass when the stock has a low abundance, and when b is less than one, the index is more sensitive to changes when the stock is large.","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"We also include two models for harvest. In general, harvest can be modeled in continuous time as a function of biomass and the fishing mortality rate","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"H_t = int_tt+Delta t theta B(u)F(u)du","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"where theta is a conversion factor that accounts for the portion of fish killed by the fishery that is not landed and counted in harvest statistics. Our modeling framework uses a discrete-time formulation, so biomass and fishing mortality are only estimated at a single point during each period, and we must approximate the integral in the harvest equations. The simplest approximation is the product of the fishing mortality, biomass, scaling parameter, and a normally distributed error term with variance sigma_H","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"H_t = theta B_t F_t+ + epsilon_H_t \n    epsilon_Ht sim N(0sigma_H)","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"We also provide an approximation that assumes fishing mortality is constant over the interval and that the population dynamics can be approximated over the interval with exponential growth (or decay). This results in a more complicated expression that includes the per capita growth rate of the population r_t and adds the additional assumption the abundance index i_t is measured at the beginning of the period","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"H_t = theta F_t B_t (e^(r_t-F_t)* Delta t - 1 )(r_t-F_t) + epsilon_H_t \n    epsilon_Ht sim N(0sigma_H)","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"The change in biomass between periods is determined by the per capita population growth rate r_t, the fishing mortality rate F_t, process errors nu_t, and the length of time between observations Delta t","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"log(B_t+1) = log(B_t) + Delta t times (r_t - F_t) + nu_Bt \n    nu_Bt sim N(0sigma_B)","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"The growth rates r_t are modeld as a function of the current biomass log(B_t) and the biomass and fishing mortality in earlier time periods  log(B_t-1B_t-1B_t-tau F_t-1 F_t-2F_t-tau) . This function is estimated using neural networks. SciMLFishieres provides several neural network architectures, which are discussed in the following section.","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"The fishing mortality rates F_t are given a random walk prior with variance parameter sigma_F that controls how rapidly the estimated fishing mortality rates change over time. ","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"log(F_t+1) = log(F_t-1) + nu_Ft \n    nu_Ft sim N(0sigma_F)","category":"page"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"The model building seciton that follows includes a detailed description of the options avaible for the production and observation models along with the code needed to implement them. ","category":"page"},{"location":"#Package-Contents","page":"SciMlFisheries","title":"Package Contents","text":"","category":"section"},{"location":"","page":"SciMlFisheries","title":"SciMlFisheries","text":"Pages = [\"index.md\",\"ModelBuilders.md\",\"Modeltesting.md\",\"ModelEvaluation.md\"]","category":"page"}]
}
